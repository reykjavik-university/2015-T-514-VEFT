# Docker

What is Docker? It is a lightweight container, that provides an additional layer of security and abstraction. It uses the resources on the computer it is running on top of, like the kernel.

Docker is an open-source project.

## Why Docker?

For one, it is very lightweight, and simplifies both deployment and configuration of your application. All you have to do is write the `Dockerfile` that includes the setup you would have to go throught in order for it to run properly, such as installing all the dependencies, then build the Docker using that and run it.

### Main Docker benefits:

* Scalable: The containers are lightweight, you can launch and shut down containers as you need them, quickly.
* Portable: You can take a snapshot of the container and upload it to a registry (such as DockerHub).
* Deployment: The containers can run anywhere.

## Docker Components

### Core Components

* Daemon: The Docker engine, runs on the host machine.
* Client: Command line interface (CLI) that is used to interact with the daemon.

### Workflow Components

* Image: Holds the enviroment and your application.
* Container: Created from images, this is the thing you use to actually run the app.
* Registry: Public and private repositories where you can store Docker images.
* Dockerfile: Automates the image contruction.

## Dockerfile

Dockerfiles is a file that has all the instructions needed to both setup the application and run it. Docker uses this file to automatically build the Docker image that you can then deploy. Dockerfiles follow a specific format and use a specific set of instructions. 

Example: 

```docker
# Inherits from this image
FROM node:5.0.0

# Go to /app directory, created
# if it does not exist
WORKDIR /app

# Copy app files to workdir
ADD package.json /app/package.json
ADD src /app/src

# Install dependencies
RUN npm install

# Make this port accessible
# through docker daemon
EXPOSE 4730

# Run the app
CMD ["node", "src/app.js"]
```

### Deploying Docker

To get this up and running, you start with building the image from the dockerfile above:

```
docker build -t app:latest .
```

What this does is it builds the image using a dockerfile in the current directory (the dot means the current directory) and tags it with `app:latest`.

Then you can run this image as a container, like so:

```
docker run --name myapp -d -p 4730:4730 app
```

This will run the app container that has the name/tag `app`, name (--name) it `myapp`, run it in the background (-d) and connect the port of your host machine to the port (-p) on the docker daemon, the last parameter is the tag of your image you created earlier.

Now you can connect to this application using the host IP address (localhost if running locally) and the port number (Example: `localhost:4730`).

If your app uses MongoDB, you can pull and run the Mongo container by typing:

```
docker pull mongo:latest
docker run --name mongodb -d -p 27017:27017 mongo
```

Now you can connect to MongoDB as it was running on your own system. Your application can connect to this container.

However, you may not want to expose the port for MongoDB on your server to the outside world. To do this, you can run mongo without exposing the port, like so:

```
docker run --name mongodb -d mongo
```

In your app, where you open a connection to MongoDB, you usually have `localhost:27017/app`, but now, since the default Mongo port isnt open on localhost, you need change the connection string:

```javascript
// Original connect
MongoClient.connect('mongodb://localhost:27017/app', (err, db) => {
    // ...
});

// Connect using environment variables
MongoClient.connect('mongodb://' + process.env.MONGO_PORT_27017_TCP_ADDR + ':' + process.env.MONGO_PORT_27017_TCP_PORT + '/app', (err, db) => {
    // ...
});

// Connect using hosts entry
MongoClient.connect('mongodb://mongo:27017/app', (err, db) => {
    // ...
});
```

Then to have your app connect to that specific mongo container, you link them together:

```
docker run --name app -d -p 4730:4730 --link=mongodb:mongo app
```

Now you have your app live in a docker container, and your app is talking to another container that has MongoDB running.